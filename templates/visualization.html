 <!DOCTYPE html>
<meta charset="utf-8">
<head>
<link href="static/css/bootstrap.css" rel="stylesheet">
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>  
<script src="static/js/lib/d3.js"></script>
<script src="static/js/lib/underscore.js"></script>
<script src="static/js/lib/bootstrap.js"></script>
</head>
<body>



<script>

// d3.csv('/visualization_process.csv', makeForceGraph);

// function makeForceGraph() {
//    console.log("hello")
// }

d3.csv('/visualization_process.csv', function (data) {
  console.log(data);

  });

    // var nodes = {};

    // Compute the distinct nodes from the links.

    // links.forEach(function(link) {

    //     link.source = nodes[link.source] ||
    //         (nodes[link.source] = {name: link.source, source: link.source});

    //     link.target = nodes[link.target] ||
    //         (nodes[link.target] = {name: link.target, source: link.source.name});

    // });

//     var width = 960;
//     var height = 500;

//     var force = d3.layout.force()
//                   .nodes(d3.values(nodes))
//                   .size([width, height])
//                   .charge(-200)
//                   .on("tick", tick)
//                   .start();

//     var svg = d3.select("body").append("svg")
//                 .attr("width", width)
//                 .attr("height", height);


//     // define the nodes

//     var node = svg.selectAll(".node")
//                   .data(force.nodes())
//                   .enter().append("g")
//                   .attr("class", "node")
//                   .call(force.drag);

//     var color = d3.scale.category20();

//     node.append("circle")
//         .attr("r", 5)
//         .style("fill", function(d) { return color(d.source); });

//     // add the text

//     node.append("text")
//          .attr("x", 6)
//         .text(function(d) { return d.name; });

//     // "schproing!"

//     function tick() {
//         path.attr("x1", function(d) { return d.source.x; })
//             .attr("y1", function(d) { return d.source.y; })
//             .attr("x2", function(d) { return d.target.x; })
//             .attr("y2", function(d) { return d.target.y; });

//         node.attr("transform", function(d) {
//             return "translate(" + d.x + "," + d.y + ")"; });
//     }
// }


// d3.csv('/visualization_process.csv', function (data) {
//   console.log(data);
//   var width = 800, height = 800;
//   var fill = d3.scale.ordinal().range(['#827d92','#2a3285','#383435'])
//   var svg = d3.select("#chart").append("svg")
//       .attr("width", width)
//       .attr("height", height);

//    for (var j = 0; j < data.length; j++) {
//      data[j].radius = +data[j].comb / 2; //A
//      data[j].x = Math.random() * width; //B
//      data[j].y = Math.random() * height; //C
//    }
// });






// d3.csv('recordings.csv', function (data) {

        // if (error) {  //If error is not null, something went wrong.
        //   console.log(error);  //Log the error.
        // } else {      //If no error, the file loaded correctly. Yay!
        //   console.log(data);
        //  }   //Log the data.

      //Include other code to execute after successful file load here
        // console.log(data);
      // dataset = data;
      // generateVis();
       

// });

      // d3.csv('data/fuel.csv', function (error, data) {

      //   var width = 1000, height = 1000;
      //   var fill = d3.scale.ordinal().range(['#827d92','#827354','#523536','#72856a','#2a3285','#383435'])
      //   var svg = d3.select("#chart").append("svg")
      //       .attr("width", width)
      //       .attr("height", height);

      //   for (var j = 0; j < data.length; j++) {
      //     data[j].radius = +data[j].comb / 2;
      //     data[j].x = Math.random() * width;
      //     data[j].y = Math.random() * height;
      //   }

      //   var padding = 4;
      //   var maxRadius = d3.max(_.pluck(data, 'radius'));


      //   var getCenters = function (vname, size) {
      //     var centers, map;
      //     centers = _.uniq(_.pluck(data, vname)).map(function (d) {
      //       return {name: d, value: 1};
      //     });

      //     map = d3.layout.pack().size(size);
      //     map.nodes({children: centers});

      //     return centers;
      //   };

      //   var nodes = svg.selectAll("circle")
      //     .data(data);

      //   nodes.enter().append("circle")
      //     .attr("class", "node")
      //     .attr("cx", function (d) { return d.x; })
      //     .attr("cy", function (d) { return d.y; })
      //     .attr("r", 2)
      //     .style("fill", function (d) { return fill(d.make); })
      //     .on("mouseover", function (d) { showPopover.call(this, d); })
      //     .on("mouseout", function (d) { removePopovers(); })

      //   nodes.transition().duration(1000)
      //     .attr("r", function (d) { return d.radius; })

      //   var force = d3.layout.force();

      //   draw('make');

      //   $( ".btn" ).click(function() {
      //     draw(this.id);
      //   });

      //   function draw (varname) {
      //     var centers = getCenters(varname, [800, 800]);
      //     force.on("tick", tick(centers, varname));
      //     labels(centers)
      //     force.start();
      //   }

      //   function tick (centers, varname) {
      //     var foci = {};
      //     for (var i = 0; i < centers.length; i++) {
      //       foci[centers[i].name] = centers[i];
      //     }
      //     return function (e) {
      //       for (var i = 0; i < data.length; i++) {
      //         var o = data[i];
      //         var f = foci[o[varname]];
      //         o.y += (f.y - o.y) * e.alpha;
      //         o.x += (f.x - o.x) * e.alpha;
      //       }
      //       nodes.each(collide(.11))
      //         .attr("cx", function (d) { return d.x; })
      //         .attr("cy", function (d) { return d.y; });
      //     }
      //   }

      //   function labels (centers) {
      //     svg.selectAll(".label").remove();

      //     svg.selectAll(".label")
      //     .data(centers).enter().append("text")
      //     .attr("class", "label")
      //     .text(function (d) { return d.name })
      //     .attr("transform", function (d) {
      //       return "translate(" + (d.x - ((d.name.length)*3)) + ", " + (d.y - d.r) + ")";
      //     });
      //   }

      //   function removePopovers () {
      //     $('.popover').each(function() {
      //       $(this).remove();
      //     }); 
      //   }

      //   function showPopover (d) {
      //     $(this).popover({
      //       placement: 'auto top',
      //       container: 'body',
      //       trigger: 'manual',
      //       html : true,
      //       content: function() { 
      //         return "Make: " + d.make + "<br/>Model: " + d.model + "<br/>Drive: " + d.drive +
      //                "<br/>Trans: " + d.trans + "<br/>MPG: " + d.comb; }
      //     });
      //     $(this).popover('show')
      //   }

      //   function collide(alpha) {
      //     var quadtree = d3.geom.quadtree(data);
      //     return function(d) {
      //       var r = d.radius + maxRadius + padding,
      //           nx1 = d.x - r,
      //           nx2 = d.x + r,
      //           ny1 = d.y - r,
      //           ny2 = d.y + r;
      //       quadtree.visit(function(quad, x1, y1, x2, y2) {
      //         if (quad.point && (quad.point !== d)) {
      //           var x = d.x - quad.point.x,
      //               y = d.y - quad.point.y,
      //               l = Math.sqrt(x * x + y * y),
      //               r = d.radius + quad.point.radius + padding;
      //           if (l < r) {
      //             l = (l - r) / l * alpha;
      //             d.x -= x *= l;
      //             d.y -= y *= l;
      //             quad.point.x += x;
      //             quad.point.y += y;
      //           }
      //         }
      //         return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      //       });
      //     };
      //   }
      // });



// var width = 960,
//     height = 500,
//     padding = 3, // separation between same-color nodes
//     clusterPadding = 8, // separation between different-color nodes
//     maxRadius = 12;

// var n = 50, // total number of nodes
//     m = 6; // number of distinct clusters

// var color = d3.scale.category10()
//     .domain(d3.range(m));

// // The largest node for each cluster.
// var clusters = new Array(m);

// var nodes = d3.range(n).map(function() {
//   var i = Math.floor(Math.random() * m),
//       r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
//       d = {cluster: i, radius: r};
//   if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
//   return d;
// });

// // Use the pack layout to initialize node positions.
// d3.layout.pack()
//     .sort(null)
//     .size([width, height])
//     .children(function(d) { return d.values; })
//     .value(function(d) { return d.radius * d.radius; })
//     .nodes({values: d3.nest()
//       .key(function(d) { return d.cluster; })
//       .entries(nodes)});

// var force = d3.layout.force()
//     .nodes(nodes)
//     .size([width, height])
//     .gravity(.02)
//     .charge(0)
//     .on("tick", tick)
//     .start();

// var svg = d3.select("body").append("svg")
//     .attr("width", width)
//     .attr("height", height);

// var node = svg.selectAll("circle")
//     .data(nodes)
//   .enter().append("circle")
//     .style("fill", function(d) { return color(d.cluster); })
//     .call(force.drag);

// node.transition()
//     .duration(750)
//     .delay(function(d, i) { return i * 5; })
//     .attrTween("r", function(d) {
//       var i = d3.interpolate(0, d.radius);
//       return function(t) { return d.radius = i(t); };
//     });

// function tick(e) {
//   node
//       .each(cluster(10 * e.alpha * e.alpha))
//       .each(collide(.5))
//       .attr("cx", function(d) { return d.x; })
//       .attr("cy", function(d) { return d.y; });
// }

// // Move d to be adjacent to the cluster node.
// function cluster(alpha) {
//   return function(d) {
//     var cluster = clusters[d.cluster];
//     if (cluster === d) return;
//     var x = d.x - cluster.x,
//         y = d.y - cluster.y,
//         l = Math.sqrt(x * x + y * y),
//         r = d.radius + cluster.radius;
//     if (l != r) {
//       l = (l - r) / l * alpha;
//       d.x -= x *= l;
//       d.y -= y *= l;
//       cluster.x += x;
//       cluster.y += y;
//     }
//   };
// }

// // Resolves collisions between d and all other circles.
// function collide(alpha) {
//   var quadtree = d3.geom.quadtree(nodes);
//   return function(d) {
//     var r = d.radius + maxRadius + Math.max(padding, clusterPadding),
//         nx1 = d.x - r,
//         nx2 = d.x + r,
//         ny1 = d.y - r,
//         ny2 = d.y + r;
//     quadtree.visit(function(quad, x1, y1, x2, y2) {
//       if (quad.point && (quad.point !== d)) {
//         var x = d.x - quad.point.x,
//             y = d.y - quad.point.y,
//             l = Math.sqrt(x * x + y * y),
//             r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
//         if (l < r) {
//           l = (l - r) / l * alpha;
//           d.x -= x *= l;
//           d.y -= y *= l;
//           quad.point.x += x;
//           quad.point.y += y;
//         }
//       }
//       return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
//     });
//   };
// }
</script>
</body>
</html>

