<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<style>
#tooltip {
  font-size: 14px;
  line-height: 1.5em;
  position:absolute;
  padding:5px;
  z-index:100000;

  div {
    color:#fff;
    padding:5px 8px 4px 8px;
    text-align:left;
    border-radius:3px;
    -moz-border-radius:3px;
    -webkit-border-radius:3px;

    span {
      font-weight:bold;
    }
  }
}

#legend {
  ul.clusters {
    list-style: none;
    padding: 0;
    li {
      padding: 0.4em 0.8em;
      color: #fff;
      font-weight: bold;
    }
  }
}
</style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
  <div class="container">
    <div class="row">
      <div class="col-md-12"><h1>Tests! With d3! <small>Hackbrightz</small></h1></div>
      <div class="col-md-9">

        <svg></svg>

      </div>
      <div class="col-md-3">
        <div id="legend">

        </div>
      </div>
    </div>
</div>

<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
// add tool tip
(function() {
  var $body, $tip, $tipInner, touch = false;

  var updatePos = function(e) {
    if(e.originalEvent.changedTouches) {
      e = e.originalEvent.changedTouches[0];
    }
    $tip.css({
      'top': e.pageY + 0,
      'left': e.pageX + 10
    });
  };
  var hide = function() {
    $(document)
      .off('touchmove', updatePos);
    $tip.hide();
  };

  $body = $('body');
  $tip = $('#tooltip');
  if(!$tip.length) {
    $tip = $('<div id="tooltip"></div>').html('<div></div>').hide().appendTo($body);
  }
  $tipInner = $tip.find('div');

  $(document).on(touch ? 'touchstart' : 'mouseover', 'svg circle', function(e){
    var d = this.__data__;

    $tipInner.html(

            '<pre>' + d.question_text + '</pre>'

        // '<pre>' + JSON.stringify({
        //   namen: d.namen,
        //   studiengang: d.studiengang,
        //   arbeitstitel: d.arbeitstitel,
        //   quellenart: d.quellenart,
        //   quelle: d.quelle
        // }, undefined, 2) + '</pre>'
    );

    updatePos(e);
    $(document)
        .on(touch ? 'touchmove' : 'mousemove', updatePos)
        .one(touch? 'touchend' : 'mouseout', hide);
    $tip.show();
  });
// })();

$(document).on("click", 'svg circle', function(f){
    var d = this.__data__;

    $tipInner.html(

            '<pre>' + d.file_path + '</pre>'

    
    );

    // updatePos(e);
    // $(document)
    //     .on(touch ? 'touchmove' : 'mousemove', updatePos)
    //     .one(touch? 'touchend' : 'mouseout', hide);
    // $tip.show();
  });
})();

// function drawLegend(clusters, color) {
//   var ul = d3.select("#legend").append('ul').classed('clusters', 1);
//   ul.selectAll('li').data(Object.keys(clusters))
//     .enter()
//       .append('li')
//         .style('background-color', function(d) { return color(d); })
//         .text(String);
// }

// http://bl.ocks.org/mbostock/7882658
function drawClusterForceLayout(data) {
  var width = 697,
      height = 500,
      padding = 6, // separation between same-color nodes
      clusterPadding = 18; // separation between different-color nodes

  var color = d3.scale.category20();

  // The largest node for each cluster.
  var clusters = {};

  // generate random data
  // var n = 200, // total number of nodes
  //     m = 10, // number of distinct clusters
  //     maxRadius = 10;

  // var nodes = d3.range(n).map(function() {
  //   var i = Math.floor(Math.random() * m),
  //       r = Math.sqrt((i + 1) / m * -Math.log(Math.random())) * maxRadius,
  //       d = {cluster: i, radius: r};
  //   if (!clusters[i] || (r > clusters[i].radius)) clusters[i] = d;
  //   return d;
  // });

  // custom data
  var nodes = data.map(function(d) {
    var cluster = d.cluster = d.question_text; //legend text
    var total = 20;
    d.radius = Math.sqrt(total / Math.PI) * 10;
    if (!clusters[cluster] || (d.radius > clusters[cluster].radius)) { clusters[cluster] = d; }
    return d;
  });

  // Use the pack layout to initialize node positions.
  d3.layout.pack()
      .sort(null)
      .size([width, height])
      .children(function(d) { return d.values; })
      .value(function(d) { return d.radius * d.radius; })
      .nodes({values: d3.nest()
        .key(function(d) { return d.cluster; })
        .entries(nodes)});


  function tick(e) {
    node
        .each(cluster(10 * e.alpha * e.alpha))
        .each(collide(0.5))
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  }

  var force = d3.layout.force()
      .nodes(nodes)
      .size([width, height])
      .gravity(0.02)
      .charge(0)
      .on("tick", tick)
      .start();

  var svg = d3.select("body").select("svg")
      .attr("width", width)
      .attr("height", height);

  var node = svg.selectAll("circle")
      .data(nodes)
    .enter().append("circle")
      .style("fill", function(d) { return color(d.cluster); })
      .call(force.drag);

  node.transition()
      .duration(750)
      .delay(function(d, i) { return i * 5; })
      .attrTween("r", function(d) {
        var i = d3.interpolate(0, d.radius);
        return function(t) { return d.radius = i(t); };
      });

  // Move d to be adjacent to the cluster node.
  function cluster(alpha) {
    return function(d) {
      var cluster = clusters[d.cluster];
      if (cluster === d) { return; }
      var x = d.x - cluster.x,
          y = d.y - cluster.y,
          l = Math.sqrt(x * x + y * y),
          r = d.radius + cluster.radius;
      if (l !== r) {
        l = (l - r) / l * alpha;
        d.x -= x *= l;
        d.y -= y *= l;
        cluster.x += x;
        cluster.y += y;
      }
    };
  }

  // Resolves collisions between d and all other circles.
  function collide(alpha) {
    var quadtree = d3.geom.quadtree(nodes);
    return function(d) {
      var r = d.radius + Math.max(padding, clusterPadding),
          nx1 = d.x - r,
          nx2 = d.x + r,
          ny1 = d.y - r,
          ny2 = d.y + r;
      quadtree.visit(function(quad, x1, y1, x2, y2) {
        if (quad.point && (quad.point !== d)) {
          var x = d.x - quad.point.x,
              y = d.y - quad.point.y,
              l = Math.sqrt(x * x + y * y),
              r = d.radius + quad.point.radius + (d.cluster === quad.point.cluster ? padding : clusterPadding);
          if (l < r) {
            l = (l - r) / l * alpha;
            d.x -= x *= l;
            d.y -= y *= l;
            quad.point.x += x;
            quad.point.y += y;
          }
        }
        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
      });
    };
  }

  // window.drawLegend(clusters, color);
}

d3.csv('visualization_process.csv').get(function(error, data) {
  // console.log(rows[0]);
  window.drawClusterForceLayout(data);
});
</script>
</body>
</html>
